<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Searching and Sorting Techniques</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
   <div class="header">
  <h1>Algorithms Playground: Searching & Sorting Visual Guide</h1>
  <p class="subtitle">Explore Essential Sorting and Searching Techniques with Theory & Code</p>
</div>


    <div class="algo-card bubble">
        <h2>Bubble Sort</h2>
        <p>
            Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until no swaps are needed, which means the array is sorted. It's simple but not very efficient for large lists.
        </p>
        <pre><code>
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        bool swapped = false;
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                swapped = true;
            }
        }
        if (!swapped) break;
    }
}
        </code></pre>
    </div>

    <div class="algo-card insertion">
        <h2>Insertion Sort</h2>
        <p>
            Insertion Sort builds the final sorted array one item at a time. It picks each element and inserts it in its correct position into the already sorted part of the array. It is efficient for small or nearly sorted lists.
        </p>
        <pre><code>
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
        </code></pre>
    </div>

    <div class="algo-card selection">
        <h2>Selection Sort</h2>
        <p>
            Selection Sort divides the array into a sorted and unsorted region. It repeatedly selects the minimum element from the unsorted region and moves it to the end of the sorted region. Itâ€™s easy to understand but not suitable for large data sets.
        </p>
        <pre><code>
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        int minIdx = i;
        for (int j = i+1; j < n; j++) {
            if (arr[j] < arr[minIdx])
                minIdx = j;
        }
        int temp = arr[minIdx];
        arr[minIdx] = arr[i];
        arr[i] = temp;
    }
}
        </code></pre>
    </div>
<div class="algo-card merge">
    <h2>Merge Sort</h2>
    <p>
        Merge Sort is a highly efficient, divide-and-conquer sorting algorithm. It recursively divides the array into halves, sorts each half, and then merges the sorted halves to produce the final sorted array. It guarantees \(O(n \log n)\) time complexity and is stable.
    </p>
    <pre><code>
void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1, n2 = r - m;
    int L[n1], R[n2];
    for (int i = 0; i < n1; i++) L[i] = arr[l + i];
    for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];
    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2)
        arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l)/2;
        mergeSort(arr, l, m);
        mergeSort(arr, m+1, r);
        merge(arr, l, m, r);
    }
}
    </code></pre>
</div>

<div class="algo-card quick">
    <h2>Quick Sort</h2>
    <p>
        Quick Sort is another divide-and-conquer sorting algorithm. It selects a 'pivot' element and partitions the array around the pivot, recursively sorting the sub-arrays. It's often faster than Merge Sort but its worst-case is \(O(n^2)\), though the average is \(O(n \log n)\).
    </p>
    <pre><code>
int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i+1];
    arr[i+1] = arr[high];
    arr[high] = temp;
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
    </code></pre>
</div>

    <div class="algo-card radix">
        <h2>Radix Sort</h2>
        <p>
            Radix Sort is a non-comparative sorting algorithm that sorts numbers digit by digit; starting either from the least significant or the most significant digit. It uses counting sort as a subroutine for sorting digits. It is especially efficient for large numbers with a known range.
        </p>
        <pre><code>
int getMax(int arr[], int n) {
    int mx = arr[0];
    for (int i = 1; i < n; i++)
        if (arr[i] > mx)
            mx = arr[i];
    return mx;
}

void countSort(int arr[], int n, int exp) {
    int output[n];
    int count[10] = {0};
    for (int i = 0; i < n; i++)
        count[(arr[i]/exp)%10]++;
    for (int i = 1; i < 10; i++)
        count[i] += count[i-1];
    for (int i = n-1; i >= 0; i--) {
        output[count[(arr[i]/exp)%10] - 1] = arr[i];
        count[(arr[i]/exp)%10]--;
    }
    for (int i = 0; i < n; i++)
        arr[i] = output[i];
}

void radixSort(int arr[], int n) {
    int m = getMax(arr, n);
    for (int exp = 1; m/exp > 0; exp *= 10)
        countSort(arr, n, exp);
}
        </code></pre>
    </div>

    <div class="algo-card binary">
        <h2>Binary Search</h2>
        <p>
            Binary Search is an efficient algorithm to search for a target value in a sorted array. It repeatedly divides the array in half and compares the target value to the middle element, eliminating half of the remaining elements in each step. It works only on sorted arrays.
        </p>
        <pre><code>
int binarySearch(int arr[], int n, int x) {
    int l = 0, r = n - 1;
    while (l <= r) {
        int mid = l + (r - l)/2;
        if (arr[mid] == x)
            return mid;
        if (arr[mid] < x)
            l = mid + 1;
        else
            r = mid - 1;
    }
    return -1;
}
        </code></pre>
    </div>

    <div class="algo-card fibonacci">
        <h2>Fibonacci Search</h2>
        <p>
            Fibonacci Search is similar to Binary Search but instead uses Fibonacci numbers to divide the array into sections. It is useful when the cost of accessing an element depends on its location. Like binary search, the array must be sorted.
        </p>
        <pre><code>
int fibMonaccianSearch(int arr[], int x, int n) {
    int fibMMm2 = 0;   // (m-2)'th Fibonacci
    int fibMMm1 = 1;   // (m-1)'th Fibonacci
    int fibM = fibMMm2 + fibMMm1; // m'th Fibonacci
    while (fibM < n) {
        fibMMm2 = fibMMm1;
        fibMMm1 = fibM;
        fibM = fibMMm2 + fibMMm1;
    }
    int offset = -1;
    while (fibM > 1) {
        int i = std::min(offset+fibMMm2, n-1);
        if (arr[i] < x) {
            fibM = fibMMm1;
            fibMMm1 = fibMMm2;
            fibMMm2 = fibM - fibMMm1;
            offset = i;
        } else if (arr[i] > x) {
            fibM = fibMMm2;
            fibMMm1 = fibMMm1 - fibMMm2;
            fibMMm2 = fibM - fibMMm1;
        } else
            return i;
    }
    if(fibMMm1 && arr[offset+1] == x)
        return offset+1;
    return -1;
}
        </code></pre>
    </div>

    <div class="algo-card linear">
        <h2>Linear Search</h2>
        <p>
            Linear Search is the simplest search algorithm. It checks each element in the list one by one until it finds the target value or reaches the end of the list. It works on both sorted and unsorted lists but is not efficient for large datasets.
        </p>
        <pre><code>
int linearSearch(int arr[], int n, int x) {
    for (int i = 0; i < n; i++)
        if (arr[i] == x)
            return i;
    return -1;
}
        </code></pre>
    </div>

</body>
</html>
